<자주사용하는 메소드>

toBe('단순값') : 예상결과값(단순값)과 동일하다면 pass (객체,배열은 반복문을 실행하기떄문에 불가)

* 일부 수의 경우, 2진법 계산에 의해 무한소수가 되는 경우가 (Ex: 0.1 + 0.2 != 0.3)
toBeCloseTo('number') : 예상결과값(수)의 근사치라면 pass

toEqual('예상결과값(객체/배열)') : 결과값이 객체 또는 배열이고, 동일하다면 pass
toStrictEqual('예상결과값(객체/배열)') : 결과값이 객체 또는 배열이고, 객체나 배열의 형식과 동일하고, 값이 동일하다면 pass

toBeNull(), toBeUndefined(), toBeDefined() : 결과값이 Null/Undefined/Define이라면 pass
toBeTruthy(), toBeFalsy() : 결과값이 True/False이라면 pass

toBeGreaterThan('number') : 결과값이 number보다 크다면 pass
toBeGreaterThanOrEqual('number') : 결과값이 number보다 크거나 같다면 pass
toBeLessThan('number') : 결과값이 number보다 작다면 pass
toBeLessThanOrEqual('number') : 결과값이 number보다 작거나 같다면 pass

toMatch(정규표현식) : 결과값이 정규표현식을 통과하는 경우 pass

toContain(찾을요소) : 배열에 대한 테스트만 가능하고, 배열에 찾을요소가 있을 경우 pass

* expect함수에 '() => 에러발생함수'를 넣었을 경우
toThrow('메세지') : expect함수의 실행 중 에러가 빌생하고, 에러메세지가 메세지와 같다면 pass

<단위실행>
describe("메세지", 콜백함수) : 콜백함수를 통해 묶인 테스트들을 describe단위로 실행한 후 메세지 출력

<단독실행>
test.only : .only가 붙은 테스트만 실행 (나머지는 Skipped)
test.skip : .skip이 붙은 테스트만 건너뛰고 실행

<전후작업 메소드> (DB open/close작업에 주로 사용)
beforeEach(콜백) : 각 테스트 시작 전 내부 콜백함수를 실행
afterEach(콜백) : 각 테스트 종료 후 내부 콜백함수를 실행

beforeAll(콜백) : 모든 테스트 시작 전 내부 콜백함수를 실행
afterAll(콜백) : 모든 테스트 종류 후 내부 콜백함수를 실행

<실행순서>
const fn = ~;

beforeAll(~)      1
beforeEach(~)     2, 6
afterEach(~)      4, 10
afterAll(~)       12

test(~);          3

describe("a", () => {
  beforeAll(~)    5
  beforeEach(~)   7
  afterEach(~)    9
  afterAll(~)     11

  test(~);        8
})

<Mock함수>
const mockFn = jest.메소드();으로 호출

mockFn.mock.calls : expect()함수에 전달받은 인자값(들)을 배열(배열의 길이=호출횟수) 내 새로운 배열로 생성
mockFn.mock.results : 결과로 리턴된 값(들)의 배열
mockFn.mockReturnValueOnce() : 연쇄적으로 사용하여 리턴될 값들을 지정해줄 수 있음 (마지막은 mockReturnValue())
mockFn.mockResolvedValue() : 리턴될 값들을 비동기함수처럼 지정해줄 수 있음 (then과함께)


<비동기코드 메소드>

1. 실패한 경우
const fn = {
  getName : callback => {
    const name = "Mike";
    setTimeOut(() => {
      callback(name);
    }, 3000);
  }
};

test("name = Mike", () => {
  function callback(name){
    expect(name).toBe("Mike");
  }
  fn.getName(callback);
});

* Jest는 콜백함수를 Queue에서 다시 꺼내오지 않고, 기존 메인 Stack이 끝나게되면 종료됨

----------------------------------------------------------------------------
2. Try-catch

const fn = {
  getName : () => {
    const name = "Mike";
    setTimeOut(() => {
      callback(name);
      if(err){
        throw new Error('error!');
      }
    }, 3000);
  }
};

test("name = Mike", (done) => {
  function callback(name, err){
    try{
      expect(name).toBe("Mike");
      done();
    } catch(err) {
      done();
    }
  }
  fn.getName(callback);
});


* 따라서, 
1)test의 콜백에 매개변수를 넣고, 
  실행할 콜백과 같은 블록스코프 내 실행할 콜백함수 뒤 
  해당 매개변수가 종료될 때까지 기다리도록하는 방법
  (만약, 실행할 콜백함수 뒤에 test의 매개변수를 실행시켜주지 않는다면 timeOut이 표시됨)
2)try-catch문으로 감싸 timeOut(5000ms기본값)이 지나기 전에
  실행콜백함수에서 에러가 발생한다면 에러코드를 출력하게 할 수 있음

----------------------------------------------------------------------------
3-1. Promise - basic

const fn = {
  getAge : () => {
    const age = 28;
    return new Promise((res,rej) => {
      setTimeOut(() => {
        res(age);
      }, 3000);
    });
  };
};

test("age = 28", () => {
  return getAge().then(age => {
    expect(age).toBe(28);
  };
})

3-2. Promise - Resolves, Rejects matcher사용

*reolves
const fn = {
  getAge : () => {
    const age = 28;
    return new Promise((res,rej) => {
      setTimeOut(() => {
        res(age);
      }, 3000);
    });
  };
};

test("age = 28, resolve성공", () => {
  return expect(getAge()).resolves.toBe(28);
});

*Rejects
const fn = {
  getAge : () => {
    const age = 28;
    return new Promise((res,rej) => {
      setTimeOut(() => {
        rej('error');
      }, 3000);
    });
  };
};

test("age = 28, reject에러", () => {
  return expect(getAge()).rejects.toMatch('error');
});


----------------------------------------------------------------------------
4-1. Async-await
const fn = {
  getAge : async () => {
    const age = 28;
      await setTimeOut(() => {
        return age;
      }, 3000);
    });
  };
};

test("age = 28, reject에러", async () => {
  const age = await getAge();
  expect(age).toBe(28);
});

4-2. Async-await Resolves matcher
const fn = {
  getAge : () => {
    const age = 28;
    return new Promise((res,rej) => {
      setTimeOut(() => {
        res(age);
      }, 3000);
    });
  };
};

test("age = 28, resolve성공", async() => {
  await expect(getAge()).resolves.toBe(28);
});

---------------------------------------------------------------------------- 

